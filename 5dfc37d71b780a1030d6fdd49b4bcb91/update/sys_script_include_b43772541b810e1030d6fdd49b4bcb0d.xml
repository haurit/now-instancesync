<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_snc_instanc_sync.JobController</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Main controller of the application</description>
        <mobile_callable>false</mobile_callable>
        <name>JobController</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var JobController = Class.create();
JobController.prototype = {
	initialize: function (grJobConfig) {
		this.bLog = false;
		if (!grJobConfig) {
			return;
		} // if no job config
		this._gt = new global.GlobalTools();
		this._gtArray = new global.GlobalToolsArray();
		this._gtObject = new global.GlobalToolsObject();
		this._gtTable = new global.GlobalToolsTable();
		this._gtRecordRead = new global.GlobalToolsRecordRead();
		this._gtRecordWrite = new global.GlobalToolsRecordWrite();
		this._gtAttachment = new global.GlobalToolsAttachment();
		this._gtRESTAPI = new global.GlobalToolsRESTAPI(grJobConfig.getValue('connection_credential_alias'));
		this._JobCommon = new JobCommon();
		var sJSONId = grJobConfig.getValue('json_configuration');
		var _getCfg = new x_snc_json_cfg_mgr.getCfg(sJSONId);
		this.oConfig = _getCfg.getConfig();
		this.sConfig = JSON.stringify(this.oConfig);
		this._getValue = _getCfg.getValue;
		this._sJSONName = (sJSONId) ? grJobConfig.json_configuration.name : 'NA';
		this._sJobCfgId = grJobConfig.getUniqueValue();
	}, // function initialize

	insertJob: function () {
		var grJobLog = new GlideRecord('x_snc_instanc_sync_job_log');
		grJobLog.addEncodedQuery('job_config=' + this._sJobCfgId + '^status!=completed^status!=cancelled');
		grJobLog.setLimit(1);
		grJobLog.query();
		if (grJobLog.hasNext()) {
			gs.addErrorMessage(gs.getMessage('job_running'));
			return;
		} // if job running
		var oTestConnection = this._gtRESTAPI.testNOWConnection();
		if (this._gtObject.getValue('success', false, oTestConnection) !== true) {
			gs.addErrorMessage(this._gtObject.getValue('message', gs.getMessage('job_connection_error'), oTestConnection));
			return;
		} // if connection
		this.validateScheduler();
		grJobLog.setValue('job_config', this._sJobCfgId);
		var dtNow = new GlideDateTime();
		grJobLog.setValue('start_time', dtNow);
		grJobLog.setValue('status', 'not_started');
		if (grJobLog.insert()) {
			gs.addInfoMessage(gs.getMessage('job_insert_success'));
		} else {
			gs.addErrorMessage(gs.getMessage('job_insert_error'));
		} // if insert success
	}, // function startJob

	validateScheduler: function () {
		var grScheduledScript = new GlideRecord('sysauto_script');
		if (!grScheduledScript.get('970972d41b810e1030d6fdd49b4bcb6a')) {
			var oConfig = {
				sTargetTable: 'sysauto_script',
				bKeepSysId: true,
				bInsert: true,
				aQueryFields: 'sys_id'
			}; // schedule config
			var oValues = {
				active: true,
				conditional: true,
				condition: 'var _JobScheduler = new JobScheduler();\n_JobScheduler.checkScheduler();',
				name: 'JobScheduler',
				run_period: '1970-01-01 00:00:30',
				run_type: 'periodically',
				script: 'var _JobScheduler = new JobScheduler();\n_JobScheduler.runScheduler();',
				sys_name: 'JobScheduler',
				sys_package: '5dfc37d71b780a1030d6fdd49b4bcb91',
				sys_scope: '5dfc37d71b780a1030d6fdd49b4bcb91',
				sys_id: '970972d41b810e1030d6fdd49b4bcb6a'
			}; // schedule value
			var oError = {};
			var sScheduleId = this._gtRecordWrite.doRecord(oValues, oConfig, oError);
			if (!sScheduleId) {
				gs.error('JobController.validateScheduler failed to insert scheduler with error: ' + JSON.stringify(oError));
			} // if error inserting schedule
		} // if schedule exists
	}, // function validateScheduler

	checkScheduleAllowed: function () {
		if (!this.isJobRunning()) {
			var dtLastJobStartTime = this.getLastJobStartTime();
			var gtLastJobStartTime = new GlideTime();
			gtLastJobStartTime.setDisplayValueInternal(dtLastJobStartTime.getInternalFormattedLocalTime());
			var gtToday = new GlideTime();
			gtToday.setDisplayValue(new GlideTime().getDisplayValueInternal()); // use this trick to get same date for comparision
			var dtToday = new GlideDateTime();
			var iWeekday = dtToday.getDayOfWeekLocalTime();
			var sWeekCfg = (iWeekday == 6 || iWeekday == 7) ? 'oWeekendDays' : 'oWeekDays';
			var iIntervalMinutes = this._getValue('job/oScheduleCfg/iRunInterval', this._getValue('job/iRunInterval', -1));
			iIntervalMinutes = this._getValue('job/oScheduleCfg/' + sWeekCfg + '/iRunInterval', iIntervalMinutes);
			if (iIntervalMinutes == -1) {
				var aRunStartTimes = this._getValue('job/oScheduleCfg/aRunStartTimes', this._getValue('job/oScheduleCfg/aRunStartTimes', ''));
				var sRunStartTime = String(this._getValue('job/oScheduleCfg/sRunStartTime', this._getValue('job/sRunStartTime', '02:00:00')));
				aRunStartTimes = (this._gtArray.isValidArray(aRunStartTimes)) ? aRunStartTimes : [sRunStartTime];
				if (this._gtArray.isValidArray(aRunStartTimes)) {
					var gtRunStartTime = new GlideTime();
					var aDtPastStartTimes = [];
					aRunStartTimes.forEach(function (sRunStartTimeTmp) {
						sRunStartTimeTmp = (sRunStartTimeTmp.length == 8) ? sRunStartTimeTmp : sRunStartTimeTmp + ':00';
						gtRunStartTime.setDisplayValue(sRunStartTimeTmp);
						if (((gtLastJobStartTime < gtRunStartTime) || (dtLastJobStartTime.getDate() < dtToday.getDate())) && (gtToday > gtRunStartTime)) {
							aDtPastStartTimes.push(gtRunStartTime);
						} // if last job time is in the past or yesterday and the current time bigger
					}, this); // each start times
					aDtPastStartTimes.sort(function (a, b) { return b.localeCompare(a); });
					gtRunStartTime = (aDtPastStartTimes.length > 0) ? aDtPastStartTimes[0] : null;
					if (this.bLog) { gs.info('JobController.checkScheduleAllowed jobs running for job config: ' + this._sJobCfgId + ' gtLastJobStartTime: ' + String(gtLastJobStartTime) + ' gtRunStartTime: ' + String(gtRunStartTime)); }
					if (gtRunStartTime) {
						return true;
					} // if start time
				} // if run start times
			} else {
				var iPassedMinutes = Math.floor((dtToday.getNumericValue() - dtLastJobStartTime.getNumericValue()) / 60000);
				var bValidInterval = iIntervalMinutes < iPassedMinutes;
				var bBlockedTime = false;
				var aBlockedHours = this._getValue('job/oScheduleCfg/' + sWeekCfg + '/aBlockedHours', []);
				if (this._gtArray.isValidArray(aBlockedHours)) {
					bBlockedTime = aBlockedHours.some(function (oBlockedHours) {
						var sBlockStartTime = String(oBlockedHours['sStartTime']);
						sBlockStartTime = (sBlockStartTime.length == 8) ? sBlockStartTime : sBlockStartTime + ':00';
						var gtBlockStart = new GlideTime();
						gtBlockStart.setDisplayValue(sBlockStartTime);
						var sBlockEndTime = String(oBlockedHours['sEndTime']);
						sBlockEndTime = (sBlockEndTime.length == 8) ? sBlockEndTime : sBlockEndTime + ':00';
						var gtBlockEnd = new GlideTime();
						gtBlockEnd.setDisplayValue(sBlockEndTime);
						if ((gtToday > gtBlockStart) && (gtToday < gtBlockEnd)) {
							if (this.bLog) { gs.info('JobController.checkScheduleAllowed jobs running for job config: ' + this._sJobCfgId + ' gtToday: ' + gtToday.getDisplayValueInternal() + ' sStartTime: ' + gtBlockStart.getDisplayValueInternal() + ' sEndTime: ' + gtBlockEnd.getDisplayValueInternal() + ' is inside blocked time'); }
							return true;
						} // if inside blocked time	
					}, this); // each blocked times
				} // if blocked array
				if (this.bLog) { gs.info('JobController.checkScheduleAllowed jobs running for job config: ' + this._sJobCfgId + ' iIntervalMinutes: ' + iIntervalMinutes + ' iPassedMinutes: ' + iPassedMinutes + ' bValidInterval: ' + bValidInterval + ' bBlockedTime: ' + bBlockedTime); }
				if ((bValidInterval === true) && (bBlockedTime === false)) {
					return true;
				} // if interval valid and not blocked
			} // if interval minutes
		} else {
			if (this.bLog) { gs.info('JobController.checkScheduleAllowed jobs running for job config: ' + this._sJobCfgId); }
		} // if job not running
		return false;
	}, // function checkScheduleAllowed

	cancelJob: function () {
		var grJobLog = new GlideRecord('x_snc_instanc_sync_job_log');
		grJobLog.addEncodedQuery('job_config=' + this._sJobCfgId + '^status!=completed^status!=cancelled');
		grJobLog.query();
		if (grJobLog.next()) {
			var bSuccess = true;
			if (this.hasOpenTriggers(grJobLog)) {
				if (!this.removeOpenTriggers(grJobLog)) {
					bSuccess = false;
				} // if remove triggers
			} // if open triggers
			if (!this.setStatus('x_snc_instanc_sync_job_log_table_chunks', 'job_log=' + grJobLog.getUniqueValue() + '^statusNOT INcompleted,failed,cancelled', 'cancelled')) {
				bSuccess = false;
			} // If status
			if (!this.setStatus('x_snc_instanc_sync_job_log_table', 'job_log=' + grJobLog.getUniqueValue() + '^statusNOT INcompleted,cancelled', 'cancelled')) {
				bSuccess = false;
			} // If status
			if (!this.setStatus(grJobLog, '', 'cancelled', true)) {
				bSuccess = false;
			} // If status
			if (bSuccess) {
				gs.addInfoMessage(gs.getMessage('job_cancel_success'));
			} else {
				gs.addErrorMessage(gs.getMessage('job_cancel_error'));
			} // if success
		} else {
			gs.addErrorMessage(gs.getMessage('job_not_running'));
		} // if job exists
	}, // function cancelJobs

	isJobRunning: function () {
		var grJobLog = new GlideRecord('x_snc_instanc_sync_job_log');
		grJobLog.addEncodedQuery('job_config=' + this._sJobCfgId + '^status!=cancelled^status!=completed');
		grJobLog.setLimit(1);
		grJobLog.query();
		if (grJobLog.hasNext()) {
			return true;
		} else {
			return false;
		} // if job found
	}, // function isJobRunning

	getLastJobStartTime: function () {
		var dtStartTime = new GlideDateTime();
		dtStartTime.setNumericValue(0);
		var grJobLogLast = new GlideRecord('x_snc_instanc_sync_job_log');
		grJobLogLast.addEncodedQuery('job_config=' + this._sJobCfgId + '^status=completed');
		grJobLogLast.orderByDesc('sys_created_on');
		grJobLogLast.setLimit(1);
		grJobLogLast.query();
		if (grJobLogLast.next()) {
			dtStartTime.setValue(grJobLogLast.start_time);
		} // if last job
		return dtStartTime;
	}, // function getLastJobStartTime

	hasOpenTriggers: function (grJobLog) {
		var sQuery = 'document=xJoblogx^document_key=' + grJobLog.getUniqueValue();
		var grTrigger = new GlideRecord('sys_trigger');
		if (sQuery) {
			grTrigger.addEncodedQuery(sQuery);
			grTrigger.setLimit(1);
			grTrigger.query();
			if (grTrigger.hasNext()) {
				return true;
			} else {
				return false;
			} // if job found
		} else {
			return false;
		} // if query
	}, // function hasOpenTriggers

	removeOpenTriggers: function (grJobLog) {
		var sJobLogId = grJobLog.getUniqueValue();
		if (sJobLogId) {
			var sQuery = 'document=xJoblogx^document_key=' + sJobLogId;
			var iTriggerCount = this._gtRecordRead.countRecords('sys_trigger', sQuery);
			gs.warn('JobController.removeOpenTriggers query: ' + sQuery + ' will delete records: ' + iTriggerCount);
			if ((iTriggerCount) && (!isNaN(iTriggerCount)) && (iTriggerCount < 35)) {
				return this._gtRecordWrite.deleteMultiple('sys_trigger', sQuery);
			} // if less than 35
		} // if job log
	}, // function removeOpenTriggers

	setStatus: function (oRecord, sQuery, sNewStatus, bUpdate) {
		var bSuccess = true;
		var sType = this._gt.getType(oRecord);
		if (sType.indexOf('gliderecord') != -1) {
			oRecord.setValue('status', sNewStatus);
			if (bUpdate) {
				if (!oRecord.update()) {
					bSuccess = false;
					gs.error('JobController.setStatus failed to update status "' + sNewStatus + '" with error: ' + oRecord.getLastErrorMessage());
				} // if no success
			} else {
				return oRecord;
			} // if update
		} else {
			if ((gs.tableExists(oRecord)) && (sQuery)) {
				var grRecord = new GlideRecord(oRecord);
				grRecord.addEncodedQuery(sQuery);
				grRecord.query();
				while (grRecord.next()) {
					grRecord.setValue('status', sNewStatus);
					if (!grRecord.update()) {
						bSuccess = false;
						gs.error('JobController.setStatus failed to update status "' + sNewStatus + '" with error: ' + grRecord.getLastErrorMessage());
					} // if no success
				} // while records
			} else {
				bSuccess = false;
				gs.error('JobController.setStatus failed to update because table not found: ' + oRecord);
			} // if table
		} // if gliderecord
		return bSuccess;
	}, // function setStatus

	initiateJob: function (grJobLog) {
		if (this.bLog) { gs.info('JobController.initiateJob start grJobLog: ' + grJobLog.getUniqueValue()); }
		var sStatus = 'running';
		var bSuccess = false;
		try {
			var bConfigIsObject = false;
			var sTableQuery = this._getValue('job/sTableQuery', '');
			var aTables = this._getValue('job/aTables', []);
			var oTables = this._getValue('job/oTables', {});
			var iPriorityDefault = this._getValue('job/iPriorityDefault', 1000);
			if ((iPriorityDefault <= 1) && (iPriorityDefault >= 100000)) {
				iPriorityDefault = 100000;
			} // if default priority not between 1 and 100000 set 100000 as default
			var oPriorityClasses = this._getValue('job/oPriorityClasses', {});
			var iChunkSize = 2000;
			if ((!sTableQuery) && (this._gtArray.isValidArray(aTables))) {
				sTableQuery = 'nameIN' + aTables.join(',');
			} // if valid array
			if ((!sTableQuery) && (this._gt.getType(oTables) == 'object')) {
				var aObjectKeys = Object.keys(oTables);
				if (this._gtArray.isValidArray(aObjectKeys)) {
					bConfigIsObject = true;
					sTableQuery = 'nameIN' + aObjectKeys.join(',');
				} // if object keys
			} // if no query
			if (sTableQuery) {
				var grTable = this._gtRecordRead.getRecords('sys_db_object', sTableQuery);
				if ((grTable) && (grTable.hasNext())) {
					var sBaseTableId = '';
					var sTableId = '';
					var sTableName = '';
					var iPriority = iPriorityDefault;
					var oClassMap = {};
					var sMappedClass = '';
					var sQuery = '';
					var aDynamicQuery = [];
					var aDynamicDeltaLoadQuery = [];
					var bDeltaLoad = false;
					var sDeltaLoadQuery = '';
					var bUseDeltaLoadQuery = false;
					var sDeltaQuery = '';
					var aQuerySysIds = [];
					var aDeltaLoadQuerySysIds = [];
					var bSplitTables = false;
					var iAutoExtendedTables = -1;
					var iTableCount = 0;
					var aTableExtensions = [];
					var oTableCount = {};
					var sTableCountId = '';
					var sClassQuery = '';
					var gdtStart = new GlideDateTime();
					var gdtEnd = new GlideDateTime();
					var iRESTRequestDuration = -1;
					var bInitialJob = false;
					var dtStartTime = this.getLastJobStartTime();
					if (dtStartTime.getNumericValue() == 0) {
						bInitialJob = true;
					} // if last job log
					while (grTable.next()) {
						sTableId = grTable.getUniqueValue();
						sBaseTableId = sTableId;
						sTableName = grTable.getValue('name');
						var grTarget = new GlideRecord(sTableName);
						sMappedClass = '';
						var aHierarchy = this._gtTable.getTableHierarchy(sTableName);
						var oTableJobCfg = {};
						sDeltaQuery = '';
						iPriority = iPriorityDefault;
						if (bConfigIsObject) {
							oTableJobCfg = this._getValue('job/oTables/' + sTableName, '');
						} else {
							if (this._gtArray.isValidArray(aHierarchy)) {
								aHierarchy.some(function (sTableInHierarchy) {
									if (sTableInHierarchy != 'cmdb') {
										oTableJobCfg = this._JobCommon.getTableConfig(this._sJSONName, this._getValue('job/sTableJSONPrefix', ''), sTableInHierarchy, 'job');
										if (Object.keys(oTableJobCfg).length > 0) {
											return true;
										} // if valid obj
									} // if not cmdb root
								}, this); // each table in hierarchy
							} // if hierarchy
						} // if config obj
						this.oConfig = JSON.parse(this.sConfig); // reset JSON
						this.oConfig['job'] = this._gtObject.deepMerge(this.oConfig['job'], oTableJobCfg, false);
						sQuery = this._getValue('job/sQuery', '');
						bDeltaLoad = this._getValue('job/bDeltaLoad', false);
						bUseDeltaLoadQuery = this._getValue('job/bUseDeltaLoadQuery', '');
						sDeltaLoadQuery = this._getValue('job/sDeltaLoadQuery', '');
						aDynamicQuery = this._getValue('job/aDynamicQuery', []);
						aDynamicDeltaLoadQuery = this._getValue('job/aDynamicDeltaLoadQuery', []);
						aQuerySysIds = this._getValue('job/aQuerySysIds', []);
						aDeltaLoadQuerySysIds = this._getValue('job/aDeltaLoadQuerySysIds', []);
						iChunkSize = this._getValue('job/iChunkSize', 2000);
						oClassMap = this._getValue('job/oClassMap', {});
						if (bDeltaLoad === true) {
							if (bInitialJob) {
								if (this._getValue('job/sDeltaLoadStartTime', '')) {
									dtStartTime.setDisplayValueInternal(this._getValue('job/sDeltaLoadStartTime'));
								} // if intial delta time set in config
							} else {
								var iDeltaLoadOverlapSeconds = this._getValue('job/iDeltaLoadOverlapSeconds', -1);
								iDeltaLoadOverlapSeconds = (isNaN(iDeltaLoadOverlapSeconds)) ? -1 : iDeltaLoadOverlapSeconds;
								dtStartTime.addSeconds(iDeltaLoadOverlapSeconds);
							} // if last job log
							var dtEndTime = new GlideDateTime(grJobLog.getValue('start_time'));
							sDeltaQuery = 'sys_updated_onBETWEEN' + dtStartTime + '@' + dtEndTime;
							if ((bUseDeltaLoadQuery) && (sDeltaLoadQuery)) {
								sQuery = this._gtRecordRead.combineQueries(sDeltaLoadQuery, sDeltaQuery);
							} else {
								sQuery = this._gtRecordRead.combineQueries(sQuery, sDeltaQuery);
							} // if specific delta load query
						} // if delta load query
						if (this._gtObject.isObject(oPriorityClasses)) {
							iPriority = this.getTableHierarchyPriority(sTableName, oPriorityClasses, iPriorityDefault);
						} // if priority classes
						bSplitTables = false;
						iAutoExtendedTables = -1;
						aTableExtensions = this._gtTable.getTableExtensions(sTableName);
						if ((bUseDeltaLoadQuery) && ((this._gtArray.isValidArray(aDynamicDeltaLoadQuery)) || (this._gtArray.isValidArray(aDeltaLoadQuerySysIds)))) {
							bSplitTables = true;
							bSuccess = this.initiateDynamicQueryJob(sTableName, aDynamicDeltaLoadQuery, aDeltaLoadQuerySysIds, aTableExtensions, sBaseTableId, iPriority, grJobLog, bSuccess);
						} else if ((!bUseDeltaLoadQuery) && ((this._gtArray.isValidArray(aDynamicQuery)) || (this._gtArray.isValidArray(aQuerySysIds)))) {
							bSplitTables = true;
							bSuccess = this.initiateDynamicQueryJob(sTableName, aDynamicQuery, aQuerySysIds, aTableExtensions, sBaseTableId, iPriority, grJobLog, bSuccess);
						} else if (this._gtArray.isValidArray(aTableExtensions)) {
							if (grTarget.isValidField('sys_class_name')) {
								if (this._getValue('job/bTableAutoExtend', true) === true) {
									gdtStart = new GlideDateTime();
									oTableCount = this._gtRESTAPI.doNOWRESTCount(sTableName, sQuery, 'sys_class_name');
									gdtEnd = new GlideDateTime();
									iRESTRequestDuration = gdtEnd.getNumericValue() - gdtStart.getNumericValue();
									iAutoExtendedTables = (oTableCount) ? Object.keys(oTableCount).length : -1;
									if (iAutoExtendedTables > 0) {
										iRESTRequestDuration = Math.round(iRESTRequestDuration / iAutoExtendedTables);
										Object.keys(oTableCount).forEach(function (sTableCountName) {
											sMappedClass = '';
											iPriority = iPriorityDefault;
											bSplitTables = true;
											iTableCount = oTableCount[sTableCountName];
											if (oTableCount[sTableCountName] > 0) {
												if (this._gtObject.isObject(oPriorityClasses)) {
													iPriority = this.getTableHierarchyPriority(sTableCountName, oPriorityClasses, iPriorityDefault);
												} // if priority classes
												sTableCountId = this._gtTable.getTableId(sTableCountName);
												if (sTableCountId) {
													sClassQuery = this._gtRecordRead.combineQueries(sQuery, 'sys_class_name=' + sTableCountName);
												} else if (oClassMap.hasOwnProperty(sTableCountName)) {
													sMappedClass = sTableCountName;
													sTableCountName = oClassMap[sMappedClass];
													sTableCountId = this._gtTable.getTableId(sTableCountName);
													sClassQuery = this._gtRecordRead.combineQueries(sQuery, 'sys_class_name=' + sMappedClass);
												} // if table found
												if ((sTableCountId) && (sTableCountId != 'undefined')) {
													bSuccess = true;
													this.initiateTable(sTableCountId, sTableCountName, sBaseTableId, sMappedClass, sClassQuery, iTableCount, iChunkSize, iPriority, iRESTRequestDuration, grJobLog);
												} else {
													gs.error('JobController.initiateJob table not found for ' + sTableCountName + ' count: ' + iTableCount + ' for job: ' + grJobLog.getUniqueValue());
												} // if table exists
											} // if table count
										}, this); // each count
									} else if ((bInitialJob) || (!bDeltaLoad)) {
										gs.error('JobController.initiateJob count failed for split table ' + sTableName + ' (' + sTableId + ') for job: ' + grJobLog.getUniqueValue());
									} // if table count
								} else {
									sQuery = this._gtRecordRead.combineQueries(sQuery, 'sys_class_name=' + sTableName);
								} // if table calc extend tables
							} // if has class field
						} else if ((this._getValue('job/bForceClassQuery', false) === true) && (grTarget.isValidField('sys_class_name'))) {
							sQuery = this._gtRecordRead.combineQueries(sQuery, 'sys_class_name=' + sTableName);
						} // if target or source (bForceClassQuery) extentions
						if (!bSplitTables) {
							gdtStart = new GlideDateTime();
							iTableCount = this._gtRESTAPI.doNOWRESTCount(sTableName, sQuery);
							gdtEnd = new GlideDateTime();
							iRESTRequestDuration = gdtEnd.getNumericValue() - gdtStart.getNumericValue();
							//gs.info('tomtom no split table: ' + sTableName + ' (' + sTableId + ') with count: ' + iTableCount + ' for job: ' + grJobLog.getUniqueValue() + ' query: ' + sQuery);
							if ((!iTableCount) || (isNaN(iTableCount))) {
								if ((bInitialJob) || (!bDeltaLoad)) {
									gs.error('JobController.initiateJob count failed for ' + sTableName + ' (' + sTableId + ') with query "' + sQuery + '" for job: ' + grJobLog.getUniqueValue());
								} // if initial job or not delta load
							} else if (iTableCount > 0) {
								bSuccess = true;
								this.initiateTable(sTableId, sTableName, sBaseTableId, sMappedClass, sQuery, iTableCount, iChunkSize, iPriority, iRESTRequestDuration, grJobLog);
							} // if table count
							Object.keys(oClassMap).forEach(function (sMappedClass) {
								//gs.info('tomtom sMappedClass: ' +  sMappedClass + ' sTableName: ' + sTableName + ' oClassMap[sMappedClass] ' + oClassMap[sMappedClass]);
								if (oClassMap[sMappedClass] == sTableName) {
									var oMappedTableCfg = this._JobCommon.getTableConfig(this._sJSONName, this._getValue('job/sTableJSONPrefix', ''), sMappedClass);
									var sMappedQuery = this._gtObject.getValue('job/sQuery', '', oMappedTableCfg);
									var sMappedDeltaLoadQuery = this._gtObject.getValue('job/sDeltaLoadQuery', '', oMappedTableCfg);
									var bMappedForceClassQuery = false;
									if ((bUseDeltaLoadQuery) && (sMappedDeltaLoadQuery)) {
										sQuery = this._gtRecordRead.combineQueries(sMappedDeltaLoadQuery, sDeltaQuery);
										bMappedForceClassQuery = this._gtObject.getValue('job/bForceClassQuery', '', oMappedTableCfg);
									} else if (sMappedQuery) {
										sQuery = this._gtRecordRead.combineQueries(sMappedQuery, sDeltaQuery);
										bMappedForceClassQuery = this._gtObject.getValue('job/bForceClassQuery', '', oMappedTableCfg);
									} // if delta load query
									if (bMappedForceClassQuery === true) {
										sQuery = this._gtRecordRead.combineQueries(sQuery, 'sys_class_name=' + sMappedClass);
									} else {
										var reTableName = new RegExp(sTableName, 'gi');
										sQuery = sQuery.replace(reTableName, sMappedClass);
									} // if mapped force query
									if (this._gtObject.isObject(oPriorityClasses)) {
										iPriority = this.getTableHierarchyPriority(sMappedClass, oPriorityClasses, iPriority);
									} // if priority classes
									iChunkSize = this._getValue('job/iChunkSize', iChunkSize, oMappedTableCfg);
									gdtStart = new GlideDateTime();
									iTableCount = this._gtRESTAPI.doNOWRESTCount(sMappedClass, sQuery);
									gdtEnd = new GlideDateTime();
									iRESTRequestDuration = gdtEnd.getNumericValue() - gdtStart.getNumericValue();
									//gs.info('tomtom no split table: ' + sTableName + ' (' + sTableId + ') and sMappedClass: ' + sMappedClass + ' with count: ' + iTableCount + ' for job: ' + grJobLog.getUniqueValue() + ' query: ' + sQuery);
									if ((!iTableCount) || (isNaN(iTableCount))) {
										if ((bInitialJob) || (!bDeltaLoad)) {
											gs.error('JobController.initiateJob count failed for ' + sTableName + ' (' + sTableId + ') and sMappedClass: ' + sMappedClass + ' with query "' + sQuery + '" for job: ' + grJobLog.getUniqueValue());
										} // if initial job or not delta load
									} else if (iTableCount > 0) {
										bSuccess = true;
										this.initiateTable(sTableId, sTableName, sBaseTableId, sMappedClass, sQuery, iTableCount, iChunkSize, iPriority, iRESTRequestDuration, grJobLog);
									} // if table count
								} // if mapped class found
							}, this); // each class map table
						} // if not split tables
					} // while table
				} // if table
			} // if table query
		} catch (oEx) {
			gs.error('JobController.initiateJob failed with exception for ' + grJobLog.getDisplayValue() + ' (' + grJobLog.getUniqueValue() + ') Exception: ' + String(oEx));
			sStatus = 'cancelled';
		} // catch
		if (!bSuccess) {
			gs.error('JobController.initiateJob failed to initiate tables because no valid table is found for job log ' + grJobLog.getDisplayValue() + ' (' + grJobLog.getUniqueValue() + ')');
			sStatus = 'completed';
		} // if not success
		if (this.bLog) { gs.info('JobController.initiateJob end grJobLog: ' + grJobLog.getUniqueValue() + ' bSuccess: ' + bSuccess + ' sStatus: ' + sStatus); }
		return sStatus;
	}, // function initiateJob

	getTableHierarchyPriority: function (sTableName, oPriorityClasses, iPriorityDefault) {
		var iPriority = iPriorityDefault;
		var iTmpPriority = this.getTablePriority(sTableName, oPriorityClasses);
		var aHierarchy = this._gtTable.getTableHierarchy(sTableName);
		if (this._gtArray.isValidArray(aHierarchy)) {
			aHierarchy.some(function (sTableInHierarchy) {
				if (sTableInHierarchy != 'cmdb') {
					iTmpPriority = this.getTablePriority(sTableInHierarchy, oPriorityClasses);
					if (iTmpPriority > 0) {
						iPriority = iTmpPriority;
						return true;
					} // if match
				} // if not cmdb
			}, this); // each table in hierarchy
		} else if (iTmpPriority > 0) {
			iPriority = iTmpPriority;
		} // if hierarchy
		return iPriority;
	}, // function getTableHierarchyPriority

	getTablePriority: function (sTmpTableName, oPriorityClasses) {
		var iTmpPriority = -1;
		var aClasses = [];
		Object.keys(oPriorityClasses).some(function (iObjPriority) {
			aClasses = oPriorityClasses[iObjPriority];
			if (this._gtArray.isValidArray(aClasses)) {
				if (aClasses.indexOf(sTmpTableName) != -1) {
					iTmpPriority = iObjPriority;
					return true;
				} // if table
			} // if valid array
		}, this); // some priority classes
		return iTmpPriority;
	}, // function getTablePriority

	initiateDynamicQueryJob: function (sTableName, aDynamicQuery, aQuerySysIds, aTableExtensions, sBaseTableId, iPriority, grJobLog, bSuccess) {
		var oDynamicResult = {}, aRecordCount = [], oRecordCount = {}, aTmpIds = [], sTmpClass = '', aTmpQueryIds = [], sTmpQuery = '', sTargetType = '', sTargetTableName = '', sTargetQuery = '', sSourceIdField = '', grTargetRecord, sTmpId = '', sTargetTableId = '', iMaxURLSize = 0, iMaxSysIds = 0;
		var grSourceRecord = new GlideRecord(sTableName);
		var bHasClassName = grSourceRecord.isValidField('sys_class_name');
		var gdtStart = new GlideDateTime();
		aDynamicQuery.forEach(function (oDynamicQuery) {
			sTargetType = (oDynamicQuery.hasOwnProperty('sTargetType')) ? oDynamicQuery['sTargetType'] : 'local';
			sTargetTableName = (oDynamicQuery.hasOwnProperty('sTargetTableName')) ? oDynamicQuery['sTargetTableName'] : '';
			sTargetQuery = (oDynamicQuery.hasOwnProperty('sTargetQuery')) ? oDynamicQuery['sTargetQuery'] : '';
			sSourceIdField = (oDynamicQuery.hasOwnProperty('sSourceIdField')) ? oDynamicQuery['sSourceIdField'] : '';
			if (this._gtTable.isValidTable(sTargetTableName)) {
				if (sTargetType == 'local') {
					var aRecordCount = this._gtRecordRead.countRecords(sTargetTableName, sTargetQuery, sSourceIdField);
					aRecordCount.forEach(function (aCount) {
						sTmpId = aCount[1];
						if ((sTmpId) && (aTmpIds.indexOf(sTmpId) == -1)) {
							aTmpIds.push(sTmpId);
						} // if tmp id
					}, this); // each count
				} else if (sTargetType == 'remote') {
					oRecordCount = this._gtRESTAPI.doNOWRESTCount(sTargetTableName, sTargetQuery, sSourceIdField);
					if (oRecordCount) {
						aTmpIds = this._gtArray.mergeArray(aTmpIds, Object.keys(oRecordCount), true);
					} // if record count
				} // if target type
			} // if valid table
		}, this); // each dynamic query
		if (this._gtArray.isValidArray(aQuerySysIds)) {
			aTmpIds = this._gtArray.mergeArray(aTmpIds, aQuerySysIds, true);
		} // if sysid array
		if (this._gtArray.isValidArray(aTmpIds)) {
			if ((this._gtArray.isValidArray(aTableExtensions)) && (bHasClassName)) {
				var i = 0;
				iMaxURLSize = 2000 - String(this._gtRESTAPI.sRemoteUrl).length - String(sTableName).length - 250; // add some buffer to avoid url length error
				iMaxSysIds = Math.floor(iMaxURLSize / 33);
				for (i = 0; i < aTmpIds.length; i++) {
					aTmpQueryIds.push(aTmpIds[i]);
					if (((i % iMaxSysIds == 0) && (i > 0)) || (i == aTmpIds.length - 1)) {
						sTmpQuery = 'sys_idIN' + aTmpQueryIds.join(',');
						var aRecords = this._gtRESTAPI.doNOWRESTQuery(sTableName, sTmpQuery, '', '', ['sys_id', 'sys_class_name']);
						aRecords.forEach(function (oRecord) {
							if ((oRecord.hasOwnProperty('sys_id')) && (oRecord.hasOwnProperty('sys_class_name'))) {
								sTmpClass = oRecord['sys_class_name'];
								if (!oDynamicResult.hasOwnProperty(sTmpClass)) {
									oDynamicResult[sTmpClass] = [];
								} // if new class
								oDynamicResult[sTmpClass].push(oRecord['sys_id']);
							} // if has field
						}, this); // each record
						aTmpQueryIds = [];
					} // workaround to limit URL length per call
				} // each model id
			} else {
				oDynamicResult[sTableName] = aTmpIds;
			} // if table has extensions
		} // if ids
		var gdtEnd = new GlideDateTime();
		var iRESTRequestDuration = gdtEnd.getNumericValue() - gdtStart.getNumericValue();
		var grJobLogTable, dtNow, grJobLogTableChunk;
		//gs.error('tomtom sTableName: ' + sTableName + ' oDynamicResult: ' + JSON.stringify(oDynamicResult));
		Object.keys(oDynamicResult).forEach(function (sTargetTableName) {
			sTargetTableId = this._gtTable.getTableId(sTargetTableName);
			if ((sTargetTableId) && (sTargetTableId != 'undefined')) {
				aTmpIds = oDynamicResult[sTargetTableName];
				if (this._gtRecordRead.checkRecordByQuery('x_snc_instanc_sync_job_log_table', 'job_log=' + grJobLog.getUniqueValue() + '^table=' + sTargetTableId)) {
					gs.error('JobController.initiateDynamicQueryJob table exists for ' + sTargetTableName + ' (' + sTargetTableId + ') for job: ' + grJobLog.getUniqueValue());
					return;
				} // if table exists
				grJobLogTable = new GlideRecord('x_snc_instanc_sync_job_log_table');
				grJobLogTable.initialize();
				grJobLogTable.setValue('job_log', grJobLog.getUniqueValue());
				if (iRESTRequestDuration > 0) {
					grJobLogTable.rest_request_duration.setDateNumericValue(iRESTRequestDuration);
				} // if duration
				grJobLogTable.setValue('basetable', sBaseTableId);
				grJobLogTable.setValue('table', sTargetTableId);
				dtNow = new GlideDateTime();
				grJobLogTable.setValue('start_time', dtNow);
				if (grJobLogTable.insert()) {
					if (this._getValue('job/bAttachTableJobJSONConfig', false) === true) {
						this._gtAttachment.writeAttachmentByTableId(grJobLogTable.getTableName(), grJobLogTable.getUniqueValue(), 'table_cfg_job_' + sTargetTableName + '.json', JSON.stringify(this.oConfig['job']), '', false, false);
					} // if attach JSON config to job log table
					if (this._gtRecordRead.checkRecordByQuery('x_snc_instanc_sync_job_log_table_chunks', 'job_log_table=' + grJobLogTable.getUniqueValue())) {
						gs.error('JobController.initiateDynamicQueryJob failed insert chunks because values exist for: ' + grJobLogTable.getUniqueValue());
						return;
					} // if chunk exists
					iMaxURLSize = 4000 - String(this._gtRESTAPI.sRemoteUrl).length - String(sTableName).length - 250; // add some buffer to avoid url length error
					iMaxSysIds = Math.floor(iMaxURLSize / 33);
					grJobLogTableChunk = new GlideRecord('x_snc_instanc_sync_job_log_table_chunks');
					grJobLogTableChunk.setValue('job_log', grJobLog.getUniqueValue());
					grJobLogTableChunk.setValue('job_log_table', grJobLogTable.getUniqueValue());
					grJobLogTableChunk.setValue('priority', iPriority);
					var bCalculateOnly = this._getValue('job/bCalculateOnly', false);
					if (bCalculateOnly) {
						grJobLogTableChunk.setValue('status', 'cancelled');
					} // if calc only
					var iChunks = Math.ceil(aTmpIds.length / iMaxSysIds);
					for (var iChunk = 0; iChunk < iChunks; iChunk++) {
						bSuccess = true;
						aTmpQueryIds = aTmpIds.splice(0, iMaxSysIds);
						sTmpQuery = 'sys_idIN' + aTmpQueryIds.join(',');
						grJobLogTableChunk.setValue('chunk', iChunk);
						grJobLogTableChunk.setValue('chunksize', aTmpQueryIds.length);
						grJobLogTableChunk.setValue('condition', sTmpQuery);
						grJobLogTableChunk.setValue('expected_record_count', aTmpQueryIds.length);
						if (!grJobLogTableChunk.insert()) {
							gs.error('JobController.initiateDynamicQueryJob failed insert chunk with error: ' + grJobLogTableChunk.getLastErrorMessage());
						} // if insert fails
					} // each chunk
				} // if insert table
			} else {
				gs.error('JobController.initiateDynamicQueryJob table not found for ' + sTargetTableName + ' for job: ' + grJobLog.getUniqueValue());
			} // if target table exists
		}, this); // each result table
		return bSuccess;
	}, // function initiateDynamicQueryJob

	initiateTable: function (sTableId, sTableName, sBaseTableId, sMappedClass, sQuery, iTableCount, iChunkSize, iPriority, iRESTRequestDuration, grJobLog) {
		if (!gs.tableExists(sTableName)) {
			gs.error('JobController.initiateTable table does not exists ' + sTableName + ' (' + sTableId + ') for job: ' + grJobLog.getUniqueValue());
			return;
		} // if table does not exist
		//gs.info('tomtom initiateTable sTableName: ' + sTableName + ' sMappedClass: ' + sMappedClass);
		var sTableExistMappedClassQuery = (sMappedClass) ? '^mapped_class=' + sMappedClass : '';
		if (this._gtRecordRead.checkRecordByQuery('x_snc_instanc_sync_job_log_table', 'job_log=' + grJobLog.getUniqueValue() + '^table=' + sTableId + sTableExistMappedClassQuery)) {
			gs.error('JobController.initiateTable table exists for ' + sTableName + ' (' + sTableId + ') for job: ' + grJobLog.getUniqueValue());
			return;
		} // if table exists
		//gs.info('tomtom init table: ' + sTableName + ' (' + sTableId + ') with count: ' + iTableCount + ' for job: ' + grJobLog.getUniqueValue() + ' query: ' + sQuery);
		var grJobLogTable = new GlideRecord('x_snc_instanc_sync_job_log_table');
		grJobLogTable.initialize();
		grJobLogTable.setValue('job_log', grJobLog.getUniqueValue());
		if (iRESTRequestDuration > 0) {
			grJobLogTable.rest_request_duration.setDateNumericValue(iRESTRequestDuration);
		} // if duration
		grJobLogTable.setValue('basetable', sBaseTableId);
		iChunkSize = ((isNaN(iChunkSize)) || (iChunkSize < 1) || (iChunkSize > 10000)) ? 2000 : iChunkSize;
		var iMaxClassSize = this._getValue('job/iMaxClassSize', -1);
		iMaxClassSize = (isNaN(iMaxClassSize)) ? -1 : iMaxClassSize;
		iTableCount = ((iMaxClassSize != -1) && (iTableCount > iMaxClassSize)) ? iMaxClassSize : iTableCount;
		iChunkSize = ((iMaxClassSize != -1) && (iChunkSize > iMaxClassSize)) ? iMaxClassSize : iChunkSize;
		var iChunks = Math.ceil(iTableCount / iChunkSize);
		grJobLogTable.setValue('table', sTableId);
		if (sMappedClass) {
			grJobLogTable.setValue('mapped_class', sMappedClass);
		} // if mapped class
		grJobLogTable.setValue('condition', sQuery);
		//grJobLogTable.setValue('source_record_count', iTableCount);
		//grJobLogTable.setValue('total_chunks', iChunks);
		var dtNow = new GlideDateTime();
		grJobLogTable.setValue('start_time', dtNow);
		if (grJobLogTable.insert()) {
			if (this._getValue('job/bAttachTableJobJSONConfig', false) === true) {
				this._gtAttachment.writeAttachmentByTableId(grJobLogTable.getTableName(), grJobLogTable.getUniqueValue(), 'table_cfg_job_' + sTableName + '.json', JSON.stringify(this.oConfig['job']), '', false, false);
			} // if attach JSON config to job log table
			this.insertTableChunks(sTableId, sTableName, sQuery, iTableCount, iChunkSize, iChunks, iPriority, grJobLog, grJobLogTable);
		} else {
			gs.error('JobController.initiateTable failed to insert table job for ' + sTableName + ' (' + sTableId + ') for job: ' + grJobLog.getUniqueValue());
		} // if insert failed
	}, // function initiateTable

	insertTableChunks: function (sTableId, sTableName, sQuery, iTableCount, iChunkSize, iChunks, iPriority, grJobLog, grJobLogTable) {
		var grJobLogTableChunk = new GlideRecord('x_snc_instanc_sync_job_log_table_chunks');
		grJobLogTableChunk.addEncodedQuery('job_log_table=' + grJobLogTable.getUniqueValue());
		grJobLogTableChunk.query();
		if (grJobLogTableChunk.next()) {
			gs.error('JobController.insertTableChunks failed insert chunks because values exist for: ' + grJobLogTable.getUniqueValue());
			return;
		} else {
			grJobLogTableChunk.setValue('job_log', grJobLog.getUniqueValue());
			grJobLogTableChunk.setValue('job_log_table', grJobLogTable.getUniqueValue());
			grJobLogTableChunk.setValue('priority', iPriority);
			var bCalculateOnly = this._getValue('job/bCalculateOnly', false);
			if (bCalculateOnly) {
				grJobLogTableChunk.setValue('status', 'cancelled');
			} // if calc only
			for (var iChunk = 0; iChunk < iChunks; iChunk++) {
				grJobLogTableChunk.setValue('chunk', iChunk);
				grJobLogTableChunk.setValue('chunksize', iChunkSize);
				grJobLogTableChunk.setValue('offset', iChunkSize * iChunk);
				var iExpectedRecordCount = ((iChunkSize * iChunk) < (iTableCount - iChunkSize)) ? iChunkSize : iTableCount - (iChunkSize * iChunk);
				grJobLogTableChunk.setValue('expected_record_count', iExpectedRecordCount);
				if (!grJobLogTableChunk.insert()) {
					gs.error('JobController.insertTableChunks failed insert chunk with error: ' + grJobLogTableChunk.getLastErrorMessage());
				} // if insert fails
			} // each chunk
		} // if chunk exists
	}, // function insertTableChunks

	updateTables: function (grJobLog) {
		var sStatus = '';
		var sTableId = '';
		var oTablesStatus = {};
		var oTablesChunkStatus = {};
		this.updateChunks(grJobLog);
		var gaJobLogTableChunkByTable = new GlideAggregate('x_snc_instanc_sync_job_log_table_chunks');
		gaJobLogTableChunkByTable.addEncodedQuery('job_log=' + grJobLog.getUniqueValue() + '^parent_chunkISEMPTY');
		gaJobLogTableChunkByTable.addAggregate('COUNT', 'job_log_table');
		gaJobLogTableChunkByTable.addAggregate('SUM', 'successful_record_count');
		gaJobLogTableChunkByTable.addAggregate('SUM', 'no_operation_count');
		gaJobLogTableChunkByTable.query();
		while (gaJobLogTableChunkByTable.next()) {
			sTableId = gaJobLogTableChunkByTable.getValue('job_log_table');
			var grJobLogTable = new GlideRecord('x_snc_instanc_sync_job_log_table');
			if (!grJobLogTable.get(sTableId)) {
				gs.error('JobController.updateTables failed to find table ' + sTableId + ' with error: ' + grJobLogTable.getLastErrorMessage());
			} // if not job log table
			if (!oTablesChunkStatus.hasOwnProperty(sTableId)) {
				oTablesChunkStatus[sTableId] = {
					'oStatus': {}
				}; // table status
			} // if no tableid
			oTablesChunkStatus[sTableId]['sTableDisplayName'] = grJobLogTable.getDisplayValue();
			oTablesChunkStatus[sTableId]['sTableName'] = grJobLogTable.getValue('name');
			oTablesChunkStatus[sTableId]['iSuccessRecordCount'] = Number(gaJobLogTableChunkByTable.getAggregate('SUM', 'successful_record_count'));
			oTablesChunkStatus[sTableId]['iNoOpRecordCount'] = Number(gaJobLogTableChunkByTable.getAggregate('SUM', 'no_operation_count'));
			oTablesChunkStatus[sTableId]['iTotalSuccessRecordCount'] = oTablesChunkStatus[sTableId]['iSuccessRecordCount'] + oTablesChunkStatus[sTableId]['iNoOpRecordCount'];
			var gaJobLogTableChunkByTableStatus = new GlideAggregate('x_snc_instanc_sync_job_log_table_chunks');
			gaJobLogTableChunkByTableStatus.addEncodedQuery('job_log=' + grJobLog.getUniqueValue() + '^job_log_table=' + sTableId + '^parent_chunkISEMPTY');
			gaJobLogTableChunkByTableStatus.addAggregate('COUNT', 'status');
			gaJobLogTableChunkByTableStatus.query();
			while (gaJobLogTableChunkByTableStatus.next()) {
				oTablesChunkStatus[sTableId]['oStatus'][gaJobLogTableChunkByTableStatus.getValue('status')] = gaJobLogTableChunkByTableStatus.getAggregate('COUNT', 'status');
			} // each status
		} // each table		
		Object.keys(oTablesChunkStatus).forEach(function (sTableId) {
			var grJobLogTable = new GlideRecord('x_snc_instanc_sync_job_log_table');
			if (grJobLogTable.get(sTableId)) {
				//grJobLogTable.setValue('successful_records_count', oTablesChunkStatus[sTableId]['iTotalSuccessRecordCount']);
				//if (oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('completed')) {
				//	grJobLogTable.setValue('successful_chunks', oTablesChunkStatus[sTableId]['oStatus']['completed']);
				//} // if has completed
				if (((Object.keys(oTablesChunkStatus[sTableId]['oStatus']).length == 1) && ((oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('completed')) || oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('failed'))) || ((Object.keys(oTablesChunkStatus[sTableId]['oStatus']).length == 2) && (oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('completed')) && (oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('failed')))) {
					var dtNow = new GlideDateTime();
					grJobLogTable.setValue('end_time', dtNow);
					grJobLogTable.setValue('status', 'completed');
				} else if ((oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('running')) || (oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('not_started')) || (oTablesChunkStatus[sTableId]['oStatus'].hasOwnProperty('pending_retry'))) {
					grJobLogTable.setValue('status', 'running');
				} // if all completed
				if (!grJobLogTable.update()) {
					gs.error('JobController.updateTables failed update table with error: ' + grJobLogTable.getLastErrorMessage());
				} // if update
			} // if table
		}); // each table
		var gaJobLogTable = new GlideAggregate('x_snc_instanc_sync_job_log_table');
		gaJobLogTable.addEncodedQuery('job_log=' + grJobLog.getUniqueValue());
		gaJobLogTable.addAggregate('COUNT', 'status');
		gaJobLogTable.query();
		while (gaJobLogTable.next()) {
			oTablesStatus[gaJobLogTable.getValue('status')] = gaJobLogTable.getAggregate('COUNT', 'status');
		} // while status
		if ((Object.keys(oTablesStatus).length == 1) && (oTablesStatus.hasOwnProperty('completed'))) {
			sStatus = 'completed';
		} // if all completed
		if (this.bLog) { gs.info('JobController.updateTables sStatus: ' + sStatus + ' oTablesStatus: ' + JSON.stringify(oTablesStatus) + ' oTablesChunkStatus: ' + JSON.stringify(oTablesChunkStatus)); }
		return sStatus;
	}, // function updateTables

	updateChunks: function (grJobLog, sAddlQuery) {
		var sQuery = 'status=pending_children';
		sQuery = (sAddlQuery) ? sQuery + '^' + sAddlQuery : 'job_log=' + grJobLog.getUniqueValue() + '^job_log.statusNOT INcompleted,cancelled^parent_chunkISEMPTY^' + sQuery;
		var grJobLogTableChunk = new GlideRecord('x_snc_instanc_sync_job_log_table_chunks');
		grJobLogTableChunk.addEncodedQuery(sQuery);
		grJobLogTableChunk.query();
		while (grJobLogTableChunk.next()) {
			var oChunkByParentStatus = {};
			var gaJobLogTableChunkByParent = new GlideAggregate('x_snc_instanc_sync_job_log_table_chunks');
			gaJobLogTableChunkByParent.addEncodedQuery('parent_chunk=' + grJobLogTableChunk.getUniqueValue());
			gaJobLogTableChunkByParent.addAggregate('COUNT', 'status');
			gaJobLogTableChunkByParent.addAggregate('SUM', 'successful_record_count');
			gaJobLogTableChunkByParent.addAggregate('SUM', 'no_operation_count');
			gaJobLogTableChunkByParent.addAggregate('SUM', 'error_count');
			gaJobLogTableChunkByParent.query();
			while (gaJobLogTableChunkByParent.next()) {
				var sStatus = gaJobLogTableChunkByParent.getValue('status');
				var iStatus = gaJobLogTableChunkByParent.getAggregate('COUNT', 'status');
				oChunkByParentStatus[sStatus] = { 'iStatus': iStatus };
				if (sStatus == 'completed') {
					oChunkByParentStatus[sStatus]['iSuccessRecordCount'] = Number(gaJobLogTableChunkByParent.getAggregate('SUM', 'successful_record_count'));
					oChunkByParentStatus[sStatus]['iNoOpRecordCount'] = Number(gaJobLogTableChunkByParent.getAggregate('SUM', 'no_operation_count'));
					oChunkByParentStatus[sStatus]['iErrorRecordCount'] = Number(gaJobLogTableChunkByParent.getAggregate('SUM', 'error_count'));
					oChunkByParentStatus[sStatus]['iTotalSuccessRecordCount'] = oChunkByParentStatus[sStatus]['iSuccessRecordCount'] + oChunkByParentStatus[sStatus]['iNoOpRecordCount'];
				} // if completed
			} // while child chunks
			if ((oChunkByParentStatus.hasOwnProperty('pending_children')) || (oChunkByParentStatus.hasOwnProperty('pending_retry'))) {
				this.updateChunks(grJobLog, 'parent_chunk=' + grJobLogTableChunk.getUniqueValue());
			} else {
				if ((!oChunkByParentStatus.hasOwnProperty('not_started')) && (!oChunkByParentStatus.hasOwnProperty('running')) && (oChunkByParentStatus.hasOwnProperty('completed'))) {
					grJobLogTableChunk.setValue('successful_record_count', oChunkByParentStatus['completed']['iSuccessRecordCount']);
					grJobLogTableChunk.setValue('no_operation_count', oChunkByParentStatus['completed']['iNoOpRecordCount']);
					grJobLogTableChunk.setValue('error_count', oChunkByParentStatus['completed']['iErrorRecordCount']);
					grJobLogTableChunk.setValue('status', 'completed');
				} else if (oChunkByParentStatus.hasOwnProperty('failed')) {
					grJobLogTableChunk.setValue('status', 'failed');
				} else if (oChunkByParentStatus.hasOwnProperty('cancelled')) {
					grJobLogTableChunk.setValue('status', 'cancelled');
				} // if completed
				if (!grJobLogTableChunk.update()) {
					gs.error('JobController.updateChunks failed update chunk with error: ' + grJobLogTableChunk.getLastErrorMessage());
				} // if update
			} // if all completed
		} // while chunks
	}, // function updateChunks


	/* TODO: Error Codes as Choices
	Chunk Errors
		Trigger Script
			-100 error loading copy job table or copy job
			-101 error loading copy job config or table name empty
			-102 error scope is not writable
			-106 config not found
			-105 error string size to big
			-104 undefined error during rest query
			-103 undefined error
			+ REST Error Codes
		
	Record Errors
		Trigger Script
			-99 No error details
			-98 No SysId in Payload
			-97 try catch error
		NOWCOTools Errors
			001 missing query
			002 error updating record
			003 error inserting record
			004 missing table
			005 try catch error	
	*/

	type: 'JobController',
	version: '1.0.6',
	author: 'ServiceNow Customer Outcomes, Tom Hauri',
	email: 'tom@hauri.biz',
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>tom.hauri</sys_created_by>
        <sys_created_on>2024-03-16 05:30:52</sys_created_on>
        <sys_id>b43772541b810e1030d6fdd49b4bcb0d</sys_id>
        <sys_mod_count>247</sys_mod_count>
        <sys_name>JobController</sys_name>
        <sys_package display_value="Instance Sync" source="x_snc_instanc_sync">5dfc37d71b780a1030d6fdd49b4bcb91</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Instance Sync">5dfc37d71b780a1030d6fdd49b4bcb91</sys_scope>
        <sys_update_name>sys_script_include_b43772541b810e1030d6fdd49b4bcb0d</sys_update_name>
        <sys_updated_by>tom.hauri</sys_updated_by>
        <sys_updated_on>2025-02-07 08:32:33</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>b43772541b810e1030d6fdd49b4bcb0d</id>
        <sys_created_by>tom.hauri</sys_created_by>
        <sys_created_on>2024-07-31 13:41:38</sys_created_on>
        <sys_id>2ba9c2281bf30610e50ddc61ab4bcb68</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>tom.hauri</sys_updated_by>
        <sys_updated_on>2024-07-31 13:41:38</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
